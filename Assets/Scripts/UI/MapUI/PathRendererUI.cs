using System.Collections.Generic;
using System.Linq;
using PathFinding;
using PathFinding.Rendering;
using UnityEngine;
using UnityEngine.UI.Extensions;

namespace UI.MapUI
{
	// Manage Line Renderer List that represents the Path generated by the PathFindingGenerator
	public class PathRendererUI : MonoBehaviour, IPathRenderer<UILineRenderer>
	{
		[SerializeField] private PathGenerator pathFindingGenerator;

		[SerializeField] protected List<UILineRenderer> lineRenderers = new();
		[SerializeField] protected UILineRenderer linePrefab;
		public int PathCount => lineRenderers.Count;
		public bool IsEmpty => PathCount == 0;

		private RectTransform _parentRectTransform;

		private MapRendererUI MapRenderer => GetComponentInParent<MapRendererUI>();

		[SerializeField] private float lineThickness = 1f;
		public float LineThickness
		{
			get => lineThickness;
			set
			{
				lineThickness = value;
				lineRenderers.ForEach(line => line.LineThickness = value);
			}
		}

		private void Awake() => _parentRectTransform = transform.parent.GetComponent<RectTransform>();

		private void Start()
		{
			if (pathFindingGenerator == null)
				pathFindingGenerator = PathFindingManager.Instance.mainPathFindingGenerator;

			pathFindingGenerator.OnPathAdded += AddPath;
			pathFindingGenerator.OnPathDeleted += RemovePath;
			pathFindingGenerator.OnPathUpdated += SetPath;
			pathFindingGenerator.OnAllPathsUpdated += UpdateAllLines;
			pathFindingGenerator.OnPathsCleared += ClearPaths;

			UpdateAllLines(pathFindingGenerator.Paths);
		}

		private void OnDestroy()
		{
			// Clear Line Renderer
			ClearPaths();

			if (pathFindingGenerator == null) return;

			// Unsuscribe from events
			pathFindingGenerator.OnPathAdded -= AddPath;
			pathFindingGenerator.OnPathDeleted -= RemovePath;
			pathFindingGenerator.OnPathUpdated -= SetPath;
			pathFindingGenerator.OnAllPathsUpdated -= UpdateAllLines;
			pathFindingGenerator.OnPathsCleared -= ClearPaths;
		}

		private void Update()
		{
			// Si el mapa se amplía, la línea debe regular su anchura para que sea constante visualmente
			foreach (UILineRenderer uiLineRenderer in lineRenderers)
				uiLineRenderer.LineThickness = lineThickness / MapRenderer.Zoom;
		}

		public void UpdateAllLines(Path[] paths)
		{
			for (var i = 0; i < paths.Length; i++)
				if (i >= lineRenderers.Count) AddPath(paths[i]);
				else SetPath(paths[i], i);
		}


		#region CRUD

		public void AddPath(Path path, int index = -1)
		{
			if (index == -1) index = lineRenderers.Count;

			UILineRenderer lineRenderer = Instantiate(linePrefab, transform);
			lineRenderers.Insert(index, lineRenderer);

			// Initilize properties
			lineRenderer.LineThickness = lineThickness;

			SetPath(path, index);
		}

		public void RemovePath(int index = -1)
		{
			if (index == -1) index = lineRenderers.Count - 1;

			if (Application.isPlaying) Destroy(lineRenderers[index].gameObject);
			else DestroyImmediate(lineRenderers[index].gameObject);

			lineRenderers.RemoveAt(index);
		}

		public void SetPath(Path path, int index = -1) =>
			lineRenderers[index].Points = path
				.GetPathNormalizedPoints(pathFindingGenerator.terrain) // Normalize the Path to the Terrain
				.Select(normPos => normPos * _parentRectTransform.rect.size) // Convert to Local Point
				.ToArray();

		public void ClearPaths()
		{
			foreach (UILineRenderer lineRenderer in lineRenderers)
				if (Application.isPlaying) Destroy(lineRenderer.gameObject);
				else DestroyImmediate(lineRenderer.gameObject);
			lineRenderers.Clear();
		}

		#endregion
	}
}
